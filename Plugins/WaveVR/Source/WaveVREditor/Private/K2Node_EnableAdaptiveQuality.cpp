// "WaveVR SDK
// © 2019 HTC Corporation. All Rights Reserved.
//
// Unless otherwise required by copyright law and practice,
// upon the execution of HTC SDK license agreement,
// HTC grants you access to and use of the WaveVR SDK(s).
// You shall fully comply with all of HTC’s SDK license agreement terms and
// conditions signed by you and all SDK and API requirements,
// specifications, and documentation provided by HTC to You."

#include "K2Node_EnableAdaptiveQuality.h"
#include "WaveVRBlueprintFunctionLibrary.h"
#include "EdGraphSchema_K2.h"                  //UEdGraphSchema_K2
#include "K2Node_CallFunction.h"               //UK2Node_CallFunction
#include "BlueprintActionDatabaseRegistrar.h"  //FBlueprintActionDatabaseRegistrar
#include "BlueprintNodeSpawner.h"              //UBlueprintNodeSpawner
#include "Kismet2/BlueprintEditorUtils.h"      //FBlueprintEditorUtils

#define LOCTEXT_NAMESPACE "K2Node_EnableAdaptiveQuality"
#define AQ_DEBUG 0
UK2Node_EnableAdaptiveQuality::UK2Node_EnableAdaptiveQuality(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer),
	bHasDefaultModePin(true),
	bHasFlagsPin(false)
{
#if AQ_DEBUG
	UE_LOG(LogTemp, Warning, TEXT("EnableAdaptiveQuality Ctor"));
#endif
}
struct FGetPinName
{
	static const FName& GetEnablePin() {
		static const FName TextPinName(TEXT("Enable"));
		return TextPinName;
	}

	static const FName& GetModePin() {
		static const FName TextPinName(TEXT("Mode"));
		return TextPinName;
	}

	static const FName& GetSendQualityEventPin() {
		static const FName TextPinName(TEXT("SendQualityEvent"));
		return TextPinName;
	}

	static const FName& GetAutoFoveationPin() {
		static const FName TextPinName(TEXT("AutoFoveation"));
		return TextPinName;
	}

	static const FName& GetOutputPin() {
		static const FName OutputPinName(TEXT("Return Value"));
		return OutputPinName;
	}
};

UEdGraphPin* UK2Node_EnableAdaptiveQuality::GetEnablePin()
{
	return FindPin(FString(TEXT("Enable")));
}
UEdGraphPin* UK2Node_EnableAdaptiveQuality::GetModePin()
{
	return FindPin(FString(TEXT("Mode")));
}
UEdGraphPin* UK2Node_EnableAdaptiveQuality::GetSendQualityEventPin()
{
	return FindPin(FString(TEXT("SendQualityEvent")));
}
UEdGraphPin* UK2Node_EnableAdaptiveQuality::GetAutoFoveationPin()
{
	return FindPin(FString(TEXT("AutoFoveation")));
}

void UK2Node_EnableAdaptiveQuality::AllocateDefaultPins()
{
#if AQ_DEBUG
	UE_LOG(LogTemp, Warning, TEXT("AllocateDefaultPins"));
#endif
	Super::AllocateDefaultPins();
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	// Execution pins
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	//[Input] Enable
	UEdGraphPin* InEnablePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Boolean, FGetPinName::GetEnablePin());
	K2Schema->SetPinAutogeneratedDefaultValue(InEnablePin, FString(TEXT("true")));

	//[Input] Mode
	if (bHasDefaultModePin) {
#if AQ_DEBUG
		UE_LOG(LogTemp, Warning, TEXT("AllocateDefaultPins Create Mode Pin"));
#endif
		UEnum* const MethodEnum = FindObjectChecked<UEnum>(ANY_PACKAGE, TEXT("EAdaptiveQualityMode"), true);
		UEdGraphPin* InModePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Byte, MethodEnum, FGetPinName::GetModePin());
		K2Schema->SetPinAutogeneratedDefaultValue(InModePin, MethodEnum->GetNameStringByValue(static_cast<int>(EAdaptiveQualityMode::Quality_Oriented)));
	}
	//[Input] Flags
	if (bHasFlagsPin) {
#if AQ_DEBUG
		UE_LOG(LogTemp, Warning, TEXT("AllocateDefaultPins Create Flags Pin"));
#endif
		UEdGraphPin* InSendQualityEventPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Boolean, FGetPinName::GetSendQualityEventPin());
		K2Schema->SetPinAutogeneratedDefaultValue(InSendQualityEventPin, FString(TEXT("true")));
		UEdGraphPin* InAutoFoveationPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Boolean, FGetPinName::GetAutoFoveationPin());
		K2Schema->SetPinAutogeneratedDefaultValue(InAutoFoveationPin, FString(TEXT("false")));
	}

	//[Output] Return Value
	UEdGraphPin* OutResultPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Boolean, FGetPinName::GetOutputPin());
	K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(OutResultPin);
}

void UK2Node_EnableAdaptiveQuality::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)
{
	//If Mode/Flags Pin should removed. Break the links and reset back its defaultvalue.
	FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;
	if (PropertyName == TEXT("bHasDefaultModePin") && !bHasDefaultModePin)
	{
		UEdGraphPin* DefaultPin = GetModePin();
		if (DefaultPin)
		{
			DefaultPin->ResetToDefaults();
			const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
			K2Schema->BreakPinLinks(*DefaultPin, true);
		}
	} else if (PropertyName == TEXT("bHasFlagsPin") && !bHasFlagsPin)
	{
		UEdGraphPin* SendQualityEventPin = GetSendQualityEventPin();
		if (SendQualityEventPin)
		{
			SendQualityEventPin->ResetToDefaults();
			const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
			K2Schema->BreakPinLinks(*SendQualityEventPin, true);
		}
		UEdGraphPin* AutoFoveationPin = GetAutoFoveationPin();
		if (AutoFoveationPin)
		{
			AutoFoveationPin->ResetToDefaults();
			const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
			K2Schema->BreakPinLinks(*AutoFoveationPin, true);
		}
	}
	ReconstructNode();
	Super::PostEditChangeProperty(PropertyChangedEvent);
}
void UK2Node_EnableAdaptiveQuality::OnPinChanged(UEdGraphPin * Pin)
{
#if AQ_DEBUG
	UE_LOG(LogTemp, Warning, TEXT("OnPinChanged"));
#endif
	bool ChangeEnable = (Pin->PinName.Compare(TEXT("Enable")) == 0) ? true : false;
	bool ChangeMode = (Pin->PinName.Compare(TEXT("Mode")) == 0) ? true : false;
	if (!ChangeEnable && !ChangeMode)
	{
		return;
	}

	Modify();

	bool ShouldShowMode = true;
	bool ShouldShowFlags = false;
	if (ChangeEnable)
	{
		if (!Pin->DefaultValue.Equals(TEXT("true")))
		{
			ShouldShowMode = false;
		}
	}
	if (ChangeMode)
	{
		UEnum* const MethodEnum = FindObjectChecked<UEnum>(ANY_PACKAGE, TEXT("EAdaptiveQualityMode"), true);
		ShouldShowFlags = (GetModePin()->DefaultValue == MethodEnum->GetNameStringByValue(static_cast<int>(EAdaptiveQualityMode::Customization))) ? true : false;
	}

	if (ShouldShowMode == false)
	{
		ShouldShowFlags = false;
	}

	UEdGraphPin* PtrModePin = GetModePin();
	UEdGraphPin* PtrSendQualityEventPin = GetSendQualityEventPin();
	UEdGraphPin* PtrGetAutoFoveationPin = GetAutoFoveationPin();
	// Mark to create or remove Mode pin.
	if (ShouldShowMode && PtrModePin == nullptr && !bHasDefaultModePin) {
#if AQ_DEBUG
		UE_LOG(LogTemp, Warning, TEXT("OnPinChanged Create Mode"));
#endif
		FProperty* HasDefaultPinProperty = FindFProperty<FProperty>(GetClass(), "bHasDefaultModePin");
		if (HasDefaultPinProperty)
		{
			PreEditChange(HasDefaultPinProperty);
			bHasDefaultModePin = true;
			FPropertyChangedEvent HasDefaultPinPropertyChangedEvent(HasDefaultPinProperty);
			PostEditChangeProperty(HasDefaultPinPropertyChangedEvent);
		}
	} else if (!ShouldShowMode && PtrModePin != nullptr && bHasDefaultModePin) {
#if AQ_DEBUG
		UE_LOG(LogTemp, Warning, TEXT("OnPinChanged Remove Mode"));
#endif
		FProperty* HasDefaultPinProperty = FindFProperty<FProperty>(GetClass(), "bHasDefaultModePin");
		if (HasDefaultPinProperty)
		{
			PreEditChange(HasDefaultPinProperty);
			bHasDefaultModePin = false;
			FPropertyChangedEvent HasDefaultPinPropertyChangedEvent(HasDefaultPinProperty);
			PostEditChangeProperty(HasDefaultPinPropertyChangedEvent);
		}
	}
	// Mark to create or remove Flags pin.
	if (ShouldShowFlags && PtrSendQualityEventPin == nullptr && PtrGetAutoFoveationPin == nullptr && !bHasFlagsPin) {
#if AQ_DEBUG
		UE_LOG(LogTemp, Warning, TEXT("OnPinChanged Create Flags"));
#endif
		FProperty* HasDefaultPinProperty = FindFProperty<FProperty>(GetClass(), "bHasFlagsPin");
		if (HasDefaultPinProperty)
		{
			PreEditChange(HasDefaultPinProperty);
			bHasFlagsPin = true;
			FPropertyChangedEvent HasDefaultPinPropertyChangedEvent(HasDefaultPinProperty);
			PostEditChangeProperty(HasDefaultPinPropertyChangedEvent);
		}
	} else if (!ShouldShowFlags && PtrSendQualityEventPin != nullptr && PtrGetAutoFoveationPin != nullptr && bHasFlagsPin) {
#if AQ_DEBUG
		UE_LOG(LogTemp, Warning, TEXT("OnPinChanged Remove Flags"));
#endif
		FProperty* HasDefaultPinProperty = FindFProperty<FProperty>(GetClass(), "bHasFlagsPin");
		if (HasDefaultPinProperty)
		{
			PreEditChange(HasDefaultPinProperty);
			bHasFlagsPin = false;
			FPropertyChangedEvent HasDefaultPinPropertyChangedEvent(HasDefaultPinProperty);
			PostEditChangeProperty(HasDefaultPinPropertyChangedEvent);
		}
	}

	// Notify the graph that the node has been changed
	if (UEdGraph* Graph = GetGraph())
	{
		Graph->NotifyGraphChanged();
	}
	// Mark dirty
	FBlueprintEditorUtils::MarkBlueprintAsModified(GetBlueprint());
}
void UK2Node_EnableAdaptiveQuality::PinConnectionListChanged(UEdGraphPin* ChangedPin)
{
#if AQ_DEBUG
	UE_LOG(LogTemp, Warning, TEXT("PinConnectionListChanged"));
#endif
	if (ChangedPin != nullptr)
	{
		OnPinChanged(ChangedPin);
	}
}
void UK2Node_EnableAdaptiveQuality::PinDefaultValueChanged(UEdGraphPin * Pin)
{
#if AQ_DEBUG
	UE_LOG(LogTemp, Warning, TEXT("PinDefaultValueChanged"));
#endif
	if (Pin != nullptr)
	{
		OnPinChanged(Pin);
	}
}

void UK2Node_EnableAdaptiveQuality::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
#if AQ_DEBUG
	UE_LOG(LogTemp, Warning, TEXT("ExpandNode"));
#endif
	Super::ExpandNode(CompilerContext, SourceGraph);

	//Hard reference to the static method in the BlueprintLibrary.
	UFunction* BlueprintFunction = UWaveVRBlueprintFunctionLibrary::StaticClass()->FindFunctionByName(FName(TEXT("EnableAdaptiveQuality_K2")));

	if (BlueprintFunction == NULL) {
		CompilerContext.MessageLog.Error(*LOCTEXT("InvalidFunctionName", "The function has not been found.").ToString(), this);
		return;
	}

	UK2Node_CallFunction* CallFunction = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);

	CallFunction->SetFromFunction(BlueprintFunction);
	CallFunction->AllocateDefaultPins();

	CompilerContext.MessageLog.NotifyIntermediateObjectCreation(CallFunction, this);

	//Input
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinName::GetEnablePin()), *CallFunction->FindPinChecked(TEXT("Enable")));
	if (GetModePin() != nullptr) {
		CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinName::GetModePin()), *CallFunction->FindPinChecked(TEXT("Mode")));
	}
	if (GetSendQualityEventPin() != nullptr) {
		CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinName::GetSendQualityEventPin()), *CallFunction->FindPinChecked(TEXT("SendQualityEvent")));
	}
	if (GetAutoFoveationPin() != nullptr) {
		CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinName::GetAutoFoveationPin()), *CallFunction->FindPinChecked(TEXT("AutoFoveation")));
	}

	//Output
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinName::GetOutputPin()), *CallFunction->GetReturnValuePin());

	//Exec pins
	UEdGraphPin* NodeExec = GetExecPin();
	UEdGraphPin* NodeThen = FindPin(UEdGraphSchema_K2::PN_Then);

	UEdGraphPin* InternalExec = CallFunction->GetExecPin();
	CompilerContext.MovePinLinksToIntermediate(*NodeExec, *InternalExec);

	UEdGraphPin* InternalThen = CallFunction->GetThenPin();
	CompilerContext.MovePinLinksToIntermediate(*NodeThen, *InternalThen);

	//After we are done we break all links to this node (not the internally created one)
	BreakAllNodeLinks();
}

//This method makes the node expose to blueprint menu (context menu)
void UK2Node_EnableAdaptiveQuality::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	Super::GetMenuActions(ActionRegistrar);
	UClass* Action = GetClass();
	if (ActionRegistrar.IsOpenForRegistration(Action)) {
		UBlueprintNodeSpawner* Spawner = UBlueprintNodeSpawner::Create(GetClass());
		check(Spawner != nullptr);
		ActionRegistrar.AddBlueprintAction(Action, Spawner);
	}
}

FText UK2Node_EnableAdaptiveQuality::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("K2Node_EnableAdaptiveQuality_Title", "EnableAdaptiveQuality");
}

FText UK2Node_EnableAdaptiveQuality::GetTooltipText() const
{
	return LOCTEXT("K2Node_EnableAdaptiveQuality_Tooltip", "[K2Node] Quality_Oriented mode forcibly enable SendQualityEvent and AutoFoveation. Performance_Oriented mode forcibly enable SendQualityEvent but AutoFoveation!");
}

FText UK2Node_EnableAdaptiveQuality::GetMenuCategory() const
{
	return LOCTEXT("K2Node_EnableAdaptiveQuality_MenuCategory", "WaveVR|AdaptiveQuality");
}

#undef AQ_DEBUG
#undef LOCTEXT_NAMESPACE
